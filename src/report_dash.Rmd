---
title: "Network Report"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
    social: menu
    source_code: embed
#    theme: 
#      version: 4
#      bootswatch: slate
#    includes:
#      after_body: footer.html
bibliography: ../references.bib
link-citations: TRUE
---

```{r setup, include=FALSE}
library(igraph)
library(flexdashboard)
library(knitr)
library(visNetwork)
library(skimr)
# also need the emo package ( devtools::install_github("hadley/emo") )

# options
## Set a random seed
.seed = 1337

# knitr options
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             cache=FALSE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE,
               fig.retina = 3)
opts_knit$set(width=75)
```

```{r data_load, include=FALSE}

## load in network
rgraph = readRDS("./data/sample_net.rda")

## is this network directed?
.directed = is.directed(rgraph)
## is this network multiplex?
.multiplex = is.weighted(rgraph)
## is there a group in the nodes data?
.groups = !is.null(V(rgraph)$group)

# largest component

## find ids of nodes in largest component
.components = igraph::clusters(rgraph, mode="weak")
.largest_cluster_id = which.max(.components$csize)
.largest_vert_ids <- V(rgraph)[.components$membership == .largest_cluster_id]

## get largest component
rgraph = igraph::induced_subgraph(rgraph, .largest_vert_ids)

# generate measures

## degree
rgraph = set_vertex_attr(rgraph, "degree", value = degree(rgraph, mode = "all"))
if(.directed){
  rgraph = set_vertex_attr(rgraph, "degree_in", value = degree(rgraph, mode = "in"))
  rgraph = set_vertex_attr(rgraph, "degree_out", value = degree(rgraph, mode = "out"))
}

## mean geodesic
# make distance table
.distable = distances(rgraph)
# replace inf and 0s (self) with NA for mean
.distable[is.infinite(.distable)] = NA
.distable[.distable == 0] = NA
# set values
rgraph = set_vertex_attr(rgraph, "mean_geodist", value = apply(.distable, 1, mean, na.rm = TRUE))

## normalized betweenness
rgraph = set_vertex_attr(rgraph, "norm_betweenness", value = betweenness(rgraph, directed = .directed, normalized = TRUE))

## eigenvector
rgraph = set_vertex_attr(rgraph, "evc", value = evcent(rgraph, directed = .directed)$vector)

## make visNetwork object for plotting
vnet = visNetwork::toVisNetworkData(rgraph)

```


```{r img_links, echo=FALSE}
# emojis
.net_url1 = "../img/male-teacher_emoji.png"
.net_url2 = "../img/female-student_emoji.png"
.net_url3 = "../img/female-health-worker_emoji.png"
.net_url4 = "../img/male-scientist_emoji.png"
```

Overview
================================================================================

Welcome! {data-width=400}
--------------------------------------------------------------------------------

### Welcome!

#### Report Introduction

Report generated: `r format(Sys.time(), '%B %d, %Y')`

This report will ingest pre-formatted network data and walk readers through some preliminary network metrics. All of the text in this report is generalized to any network it could render; it is not specific to the data displayed. Because of this, some metrics may not be relevant to a specific data set. Please talk with the DataLab about the outcomes of this report for help with interpretation and applications of these outcomes.

To navigate this report, use the tabs at the top of the page. Each page will walk you through one network metric and it's interpretation. The remainder of this tab will cover some network basics. If you have any questions, please contact us at <a href = "mailto:datalab@ucdavis.edu">datalab@ucdavis.edu</a>.

#### Network Background

You may be familiar with tabular data; rows and columns containing information. You can see a representation of this data to the right on top. While this is a tidy way to store data, it artificially atomizes or separates many of the things we are interested in as researchers, social or otherwise. Network analysis is a tool to work with *relational* data, a.k.a. information about how entities are connected with each other. For example, the diagram on the bottom right shows the same data as the table above, with the added benefit of showing how these individuals are connected to each other. Hover over the people to reveal the data about them.

Rather than looking only at attributes of specific data points, we are looking at the connections between data. In network analysis, data points are called *nodes* or *vertices*, and the connections between them are called *edges* or *ties*. Vertices can be anything---people, places, words, concepts---they are usually mapped into rows in a data frame. Edges contain any information on how these things connect or are related to each other. These parts create a *network* or *graph*, defined as "finite set or sets of actors and the relation or relations defined on them" [@wassermanSocialNetworkAnalysis1994].

Data Types {data-width=600}
--------------------------------------------------------------------------------

### Example Data Frame

| Person | Name | Age | Widgets |
|-|:-|:-|:-|
| ![](`r .net_url1`){width="10%"} | J | 30 | 1 |
| ![](`r .net_url2`){width="10%"} | Y | 21 | 3 |
| ![](`r .net_url3`){width="10%"} | G | 32 | 4 |
| ![](`r .net_url4`){width="10%"} | Z | 48 | 8 |

### Example Network

```{r echo=FALSE, out.width='100%'}
.toy_nodes = data.frame(id = 1:4, 
                    shape = "image",
                    title = c("<p style='color: black;'>Name: J<br>Age: 30<br>Widgets: 1</p>", "<p style='color: black;'>Name: Y<br>Age: 21<br>Widgets: 3</p>", "<p style='color: black;'>Name: G<br>Age: 32<br>Widgets: 4</p>", "<p style='color: black;'>Name: Z<br>Age: 48<br>Widgets: 8</p>"),
                    image = c(.net_url1, .net_url2, .net_url3, .net_url4))

.toy_edges = data.frame(from = c(2,4,3,3), to = c(1,2,4,2), label = c("Siblings", "Student", "Friends", "Parent"))

.toy_net = visNetwork(.toy_nodes, .toy_edges, width = "100%") %>% 
  visNodes(shapeProperties = list(useBorderWithImage = FALSE), size = 50) %>%
  visEdges(length = 200, scaling = list(min = 400)) %>%
  visInteraction(zoomView = FALSE) %>%
  visLayout(randomSeed = 2)

.toy_net$sizingPolicy$browser$fill = TRUE

.toy_net
```

Network Metadata
================================================================================

Explanation Text
--------------------------------------------------------------------------------

### Network Characteristics {data-height=320}

| Network Property | Measurement |
|:-|:-|
| Nodes | `r vcount(rgraph)` |
| Edges | `r ecount(rgraph)` | 
| Directed | `r ifelse(.directed, emo::ji("check"), emo::ji("x"))` |
| Weighted Edges| `r ifelse(.multiplex, emo::ji("check"), emo::ji("x"))` |
| Projected | PLACEHOLDER |
| Density | `r round(edge_density(rgraph), digits = 3)` | 
| Degree Centralization  | `r round(centralization.degree(rgraph, mode = "all", normalized = TRUE)$centralization, digits = 3)` |
| Betweenness Centralization | `r round(centralization.betweenness(rgraph, directed = .directed, normalized = TRUE)$centralization, digits = 3)` |
| Eigenvector Centralization | `r round(centralization.evcent(rgraph, directed = .directed, normalized = TRUE)$centralization, digits = 3)` |

### Explanations

#### Overview

This tab contains some meta-information about the network. This includes the number of nodes and edges, as well as more specialized characteristics and measures. The rest of this space is dedicated to explaining those things in a general way. If you would like to see more information about specific nodes in the network, you can hover over them on the right to see a tooltip about that node. You can also find nodes sorted alphabetically in the top left pull-down menu.

#### Directed/Un-Directed

Networks can either be *directed* or *un-directed*. A directed network treats the edges between nodes as having a specific direction of flow, while an un-directed network considers all edges to be mutual. An example of each is presented below.

A directed network tracks which node is the source and which node is the receiver for an edge. Take for example the *follow* mechanic on Twitter. User A can follow User B, creating a directed edge from A to B, but B does not have to follow A in return. This can be useful when trying to understand the flows of resources that are finite such as money or goods.

An un-directed network treats all ties as mutual, such that A and B are both involved equally in a tie. An example is the *friend* mechanic on Facebook. Once a friendship is established, both users are considered equal in the tie. This can be helpful when you do not have information on what node initiates a tie, or when events happen equally to a group of nodes, such as all nodes being connected through co-membership in a group.

Which of these will be useful to you will likely change from project to project. However, it is vital to understand what kind of network you are working with, as many network calculations we will talk about later change their behavior based on if the network is directed or not.

#### Weighted Edges

Edges in most network are un-weighted, such that edges either exist or they do not. It is possible to have weighted edges in a network, such that some edges are considered more important than others. This is often used to represent multiple interactions. For example if your network is composed of people, an un-weighted edge might denote two individuals as friends, whereas a weighted edge may indicate how many time two individuals spend time together; in this situation an edge weight of 1 would be one meeting, while and edge weight of 5 would be five meetings.

#### Projected/Bipartite

Often, you will not have individual level network data, but you will have data on group membership. For example, if you wanted to map the social networks of student, but don't know who they actually hang around with, you may be able to use class rosters to build an approximate network. This is call a *bipartite network*, *two-mode*, or *projected network*. You can "collapse" such a network into a student network by assuming every student connected to a class is connected to each other. The same is true with classes, such that classes are related to each other if a single student is enrolled in both. This assumption may not always be correct, and you need to take care if you are going to make it in your research. If a class has 300 students, it is most likely not correct to assume every student knows every other student in that class.

#### Density

*Density* is the first real graph level metric that helps you understand what is particular about the network you are looking at. The density of a network is a numerical score showing how many ties exist in a network, given the max possible in that network. Mathematically that is $\frac{Actual Edges}{Possible Edges}$, where actual edges is the number of edges in the network, and possible edges is the number of edges if every single node in the network was connected to every other node.

Networks that are more densely connected are considered to be more cohesive and robust. This means that the removal of any specific edge or node will not have a great effect of the network as a whole. It also typically means that any one node in the network will be more likely to have access to whatever resources are in the network, as there are more potential connections in the network to search for resources.

#### Centralization

*Freeman Centralization* (usually just called *centralization*) gives a sense of the shape of the network, namely how node level measures are distributed in a network. We'll discuss node level measures next, but for now it is only important to understand that node level measures are numeric scores assigned to specific nodes rather than the network as a whole. This means that each node may have a different value.

Centralization is a measure of how unevenly node level metrics are distributed in a network. Scores closer to 0 mean the metric is evenly distributed, while scores closer to 1 indicate a concentration of the metric with a few nodes.

Network Viewer
--------------------------------------------------------------------------------

### Network Overview

```{r echo=FALSE}
overview_net = vnet$nodes

overview_net$title = paste0("<table>",
                              "<tr>",
                                "<th>Measurement</th>",
                                "<th>Value</th>",
                              "</tr>",
                              "<tr>",
                                "<td>Node ID</td>",
                                "<td>", overview_net$id, "</td>",
                              "</tr>",
                              if(.groups){paste0(
                                "<tr>",
                                  "<td>Group</td>",
                                  "<td>", overview_net$group, "</td>",
                                "</tr>")
                              },
                              "<tr>",
                                "<td>Total Degree</td>",
                                "<td>", round(overview_net$degree, digits = 3), "</td>",
                              "</tr>",
                              if(.directed){paste0(
                                "<tr>",
                                  "<td>Total In Degree</td>",
                                  "<td>", round(overview_net$degree_in, digits = 3), "</td>",
                                "</tr>",
                                "<tr>",
                                  "<td>Total Out Degree</td>",
                                  "<td>", round(overview_net$degree_out, digits = 3), "</td>",
                                "</tr>")
                              },
                              "<tr>",
                                "<td>Mean Geodesic Distance</td>",
                                "<td>", round(overview_net$mean_geodist, digits = 3), "</td>",
                              "</tr>",
                              "<tr>",
                                "<td>Norm Betweenness Centrality</td>",
                                "<td>", round(overview_net$norm_betweenness, digits = 3), "</td>",
                              "</tr>",
                              "<tr>",
                                "<td>Eigenvector Centrality</td>",
                                "<td>", round(overview_net$evc, digits = 3), "</td>",
                              "</tr>",
                            "</table>")

visNetwork(overview_net, vnet$edges) %>%
  visInteraction(zoomView = FALSE, dragView = FALSE) %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE, selectedBy = if(.groups){"group"} else {NULL}) %>%
  visLayout(randomSeed = .seed)
```

Degree
================================================================================

Degree Text
--------------------------------------------------------------------------------

### Degree Measure

#### Description

*Degree* counts how many edges are connected to a node. Degree gives a very rough measure of how popular or central a node is in the network. If a node has more ties, it may indicate that node as being more central or important in the network as a whole. Degree is a raw count of the number of edges a node has, this makes the interpretation of degree highly dependent on the size of the network. In a small network with only 25 total edges, having 10 of them would be significant. In a larger network with 250 total edges, 10 edges could be less impressive. Degree should thus be interpreted in the context of other nodes in the network. 

Degree count can be affected if the network is un-directed or directed; this network is `r ifelse(.directed, paste0("**directed**, so the following will apply"), paste0("**un-directed**, so the following will not apply"))`. If the network is directed there will be different counts for in-degree and out-degree. In-degree counts the number of edges a node is receiving, while out-degree counts the number of edges a node is sending. Total degree is the sum of these two numbers. If a node is receiving many edges but does not send any, this can be indicative of it's role in the network, though the meaning of this pattern will be specific to each case.

#### In This Network

```{r echo=FALSE}
skim_without_charts(vnet$nodes$degree) %>% yank("numeric")
if(.directed){
  skim_without_charts(vnet$nodes$degree_in) %>% yank("numeric")
  skim_without_charts(vnet$nodes$degree_out) %>% yank("numeric")
}
```

`r if(.directed) {"<!--"}`

This network is an un-directed network, meaning all edges are mutual. This network has a total of `r ecount(rgraph)` edges. The network on the right has the nodes scaled such that larger nodes have a higher total degree. The node highlighted in yellow in the right has the highest total degree at `r max(vnet$nodes$degree)` (`r round((max(vnet$nodes$degree)/ecount(rgraph))*100, digits = 3)`% of all edges). The node(s) highlighted in grey has the lowest total degree at `r min(vnet$nodes$degree)`

`r if(.directed) {"-->"}`


`r if(!.directed) {"<!--"}`

This network is a directed network, meaning all edges are being sent by one node and received by another. This network has a total of `r ecount(rgraph)` edges. The network on the right has the nodes scaled such that larger nodes have a higher total degree. The node highlighted in yellow in the right has the highest total degree at `r max(vnet$nodes$degree)`, with an in-degree of `r vnet$nodes[which(vnet$nodes$degree == max(vnet$nodes$degree)), "degree_in"]` and an out-degree of `r vnet$nodes[which(vnet$nodes$degree == max(vnet$nodes$degree)), "degree_out"]`. The node(s) highlighted in grey has the lowest total degree at `r min(vnet$nodes$degree)`

`r if(!.directed) {"-->"}`

Network Viewer
--------------------------------------------------------------------------------

### Degree Network

```{r echo=FALSE}
# make dataframe for vis of degree
degree_df = vnet$nodes
degree_df$value = degree_df$degree ^ 2
degree_df$color = "#355B85"

# add color for largest node
degree_df[which(max(degree_df$degree) == degree_df$degree), "color"] = "#FFBF00"
degree_df[which(min(degree_df$degree) == degree_df$degree), "color"] = "#CDD6E0"

# add label
degree_df$label = paste0(degree_df$id, "\n", round(degree_df$degree, 3))

visNetwork(degree_df, vnet$edges) %>%
  visInteraction(zoomView = FALSE, dragView = FALSE) %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
  visLayout(randomSeed = .seed)
```

### Degree Plot

```{r echo=FALSE}
hist(vnet$nodes$degree, main = "Degree Frequency", xlab = "Total Degree")
```

Geodesic Distance
================================================================================

Geodesic Distance Text
--------------------------------------------------------------------------------

### Geodesic Distance Measure

#### Description

**Geodesic Distance** is "the length of the shortest path via the edges or binary connections between nodes" [@kadushinUnderstandingSocialNetworks2012]. In other words, if we treat the network as a map we can move along, with the nodes being stopping places and the edges being paths, the geodesic is the shortest possible path we can use to walk between two nodes. 

Nodes that on average have a shorter geodesic distance between all the other nodes in the network are considered to have have greater access to the resources in a network. This is because a node with a low average geodesic distance can theoretically "reach" the other nodes with less effort because it does not need to travel as far. This is our first instance of how network structure, not node attributes, can inform us about the nodes in a network. Essentially, looking at the network as a whole can tell us things about the people in it that is lost if we look only at individuals.

Note that while there is a correlation between degree counts and mean geodesic distance, one does not cause the other.

#### In This Network

```{r echo=FALSE}
skim_without_charts(vnet$nodes$mean_geodist) %>% yank("numeric")
```
The mean geodesic distance in this network is `r round(mean(vnet$nodes$mean_geodist), digits = 3)`. The network on the right has the nodes scaled such that larger nodes have a **lower** mean geodesic distance. The node highlighted in yellow in the right has the lowest mean geodesic distance at `r round(min(vnet$nodes$mean_geodist), digits = 3)`; it will usually be centrally located in the network. The grey node has the highest at `r round(max(vnet$nodes$mean_geodist), digits = 3)`, and would need to travel through the whole network to reach the nodes on the opposite side.

Network Viewer
--------------------------------------------------------------------------------

### Geodesic Distance Network

```{r Geodesic, echo=FALSE, message=FALSE, warning=FALSE}
# make df to vis geodesic distances
gdist_df = vnet$nodes
gdist_df$value = (gdist_df$mean_geodist * -1)
gdist_df$color = "#355B85"

# replace min average geodesic with gold, max with grey
gdist_df$color[which(gdist_df$mean_geodist == min(gdist_df$mean_geodist))] = "#FFBF00"
gdist_df$color[which(gdist_df$mean_geodist == max(gdist_df$mean_geodist))] = "#CDD6E0"

# add label as geodesic distance, rounding to 3 digits
gdist_df$label = paste0(gdist_df$id, "\n", round(gdist_df$mean_geodist, 3))

# plot
visNetwork(gdist_df, vnet$edges) %>%
  visInteraction(zoomView = FALSE, dragView = FALSE) %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
  visLayout(randomSeed = .seed)
```

### Geodesic Distance Plot

```{r echo=FALSE}
hist(vnet$nodes$mean_geodist, main = "Mean Geodesic Distance", xlab = "Geodesic Distance")
```

Betweenness
================================================================================

Betweenness Text
--------------------------------------------------------------------------------

### Betweenness

#### Description

**Betweenness Centrality** tries to calculate the extent to which a node acts as a gatekeeper or *broker* in the network. A broker bridges two otherwise disconnected segments in a network. If there are two parts of a network that would otherwise be broken apart if a node was removed, they would have a high betweenness centrality. The fragmenting of a network is not a prerequisite however, simply acting as an effective "shortcut" in a network can also raise a node's betweenness centrality. Betweenness is calculated using geodesic distances, and gives a higher score to nodes that lie on more geodesic paths.

Centrality scores such as this are usually normalized such that their scores all sum to 1. This way, you can easily compare nodes within the network (but not between networks), and understand how nodes relate to each other structurally. It is possible for a node to have a 0 betweenness score if no geodesic distances pass through them.

#### In This Network

```{r echo=FALSE}
skim_without_charts(vnet$nodes$norm_betweenness) %>% yank("numeric")
```

The mean betweenness centrality in this network is `r round(mean(vnet$nodes$norm_betweenness), digits = 3)`. The network on the right has the nodes scaled such that larger nodes have a larger betweenness centrality. The node highlighted in gold on the right has the largest betweenness centrality at `r round(max(vnet$nodes$norm_betweenness), digits = 3)`; this node likely acts as a gatekeeper in the network. Imagine this node were removed, how would resources need to flow differently in the network without it? The grey node has the smallest betweenness centrality at `r round(min(vnet$nodes$norm_betweenness), digits = 3)`; the network would likely be unaffected by their removal in terms of resource flows.  

Betweenness Viewer
--------------------------------------------------------------------------------

### Betweenness Network

```{r betweenness, echo=FALSE, message=FALSE, warning=FALSE}

bet_df = vnet$nodes
bet_df$value = bet_df$norm_betweenness
bet_df$color = "#355B85"

# add label as geodesic distance, rounding to 3 digits
bet_df$label = paste0(bet_df$id, "\n", round(bet_df$norm_betweenness, 3))


# replace max average geodesic with gold, min with grey
bet_df$color[which(bet_df$norm_betweenness == max(bet_df$norm_betweenness))] = "#FFBF00"
bet_df$color[which(bet_df$norm_betweenness == min(bet_df$norm_betweenness))] = "#CDD6E0"

# plot
visNetwork(bet_df, vnet$edges) %>%
  visInteraction(zoomView = FALSE, dragView = FALSE) %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
  visLayout(randomSeed = .seed)
```

### Betweenness Plot

```{r echo=FALSE}
hist(vnet$nodes$norm_betweenness, main = "Normalized Betweenness", xlab = "Node Betweenness")
```

Eigenvector
================================================================================

Eigenvector Text
--------------------------------------------------------------------------------

### Eigenvector Header

#### Description

**Eigenvector Centrality** is commonly known as a measure of "popular friends." Rather than looking at the network position of a node, it looks at the network positions of nodes connected to it. Nodes with a high eigenvector score will be connected to nodes more prominent in the network. Nodes with low degree can have high eigenvector scores if they are connected to important nodes. In real life networks this can be interpreted as being close to influential others in a network.

#### In This Network

```{r echo=FALSE}
skim_without_charts(vnet$nodes$evc) %>% yank("numeric")
```

The mean eigenvector centrality in this network is `r round(mean(vnet$nodes$evc), digits = 3)`. The network on the right has the nodes scaled such that larger nodes have a larger eigenvector centrality. The node highlighted in gold on the right has the largest eigenvector centrality at `r round(max(vnet$nodes$evc), digits = 3)`; this node may not be the most central node in the network, but it is connected to many important partners. The grey node has the smallest eigenvector centrality at `r round(min(vnet$nodes$evc), digits = 3)`.

This network has a eigenvector centralization of `r round(centralization.evcent(rgraph, directed = .directed, normalized = TRUE)$centralization, digits = 3)`. Centralization is a measure of how unevenly node level metrics are distributed in a network. Scores closer to 0 mean the metric is evenly distributed, while scores closer to 1 indicate a concentration of the metric with a few nodes.

Eigenvector Viewer
--------------------------------------------------------------------------------

### Eigenvector Network

```{r eigenvector, echo=FALSE, message=FALSE, warning=FALSE}
evc_df = vnet$nodes
evc_df$value = evc_df$evc
evc_df$color = "#355B85"

# add label as geodesic distance, rounding to 3 digits
evc_df$label = paste0(evc_df$id, "\n", round(evc_df$evc, 3))

# replace min average geodesic with gold, min with grey
evc_df$color[which(evc_df$evc == max(evc_df$evc))] = "#FFBF00"
evc_df$color[which(evc_df$evc == min(evc_df$evc))] = "#CDD6E0"

# plot
visNetwork(evc_df, vnet$edges) %>%
  visInteraction(zoomView = FALSE, dragView = FALSE) %>%
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
  visLayout(randomSeed = .seed)
```

### Eigenvector Plot

```{r echo=FALSE}
hist(vnet$nodes$evc, main = "Eigenvector Betweenness", xlab = "Node Eigenvector")
```

`r if(!.groups) {"<!--"}`

Groups
================================================================================

Groups Text
--------------------------------------------------------------------------------

### Groups Header

#### Description

One of the most useful aspects of network analysis is the ability to compare how different groups are positioned within a network. If one group has a significantly higher average degree for example, they would be involved in, and thus control over, more of the network compared to other groups. The plot on the right shows the nodes in your network with colors representing each group. You should inspect the plot visually to see if nodes of specific groups cluster together in some way (though note the layout of the graph is arbitrary).

#### In This Network

```{r echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

for(group in unique(vnet$nodes$group)){
  
  cat(paste0("##### Group: ", group))
  
  if(.directed){
    cat(knit_print(skim_without_charts(vnet$nodes[vnet$nodes$group == group,], c("degree", "degree_in", "degree_out", "mean_geodist", "norm_betweenness", "evc")) %>% yank("numeric")))
  } else {
    cat(knit_print(skim_without_charts(vnet$nodes[vnet$nodes$group == group,], c("degree", "mean_geodist", "norm_betweenness", "evc")) %>% yank("numeric")))
    }
  
}
```



Groups Viewer
--------------------------------------------------------------------------------

### Groups Network

### Groups Plot

`r if(!.groups) {"-->"}`







<!--

Template
================================================================================

Template Text
--------------------------------------------------------------------------------

### Template Header

#### Description

#### In This Network

Template Viewer
--------------------------------------------------------------------------------

### Degree Network

### Degree Plot

-->






Credits
================================================================================

DataLab {data-width=600}
--------------------------------------------------------------------------------

### About

This report was coded by [Jared Joseph](https://jnjoseph.com/) for the [UC Davis DataLab](https://datalab.ucdavis.edu/); I hope you found it useful! 

References {data-width=400}
--------------------------------------------------------------------------------

### References






