---
title: "Network Report"
output: 
  flexdashboard::flex_dashboard:
    orientation: columns
    vertical_layout: fill
bibliography: ../references.bib
link-citations: TRUE
---

```{r setup, include=FALSE}
library(flexdashboard)
library(knitr)
library(rmdformats)
library(statnet)
library(visNetwork)

# options

.seed = 1337

# knitr options
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             cache=FALSE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)
```

```{r data_load, include=FALSE}
# read in attributes and edgelist
nodes = read.csv("./data/nodes.csv", header = TRUE, stringsAsFactors = FALSE)
edges = read.csv("./data/edges.csv", header = TRUE, stringsAsFactors = FALSE)

# make a network

## sort your attributes frame alphabetically. Super important!
nodes = nodes[order(nodes$id), ]
## make network!
rgraph = network(edges, directed = FALSE, matrix.type = "edgelist")

# largest component

## find what nodes are part of the largest component
rgraph%v%"lc" = component.largest(rgraph)
## delete those nodes that are not
### in the network
rgraph = delete.vertices(rgraph, which(rgraph%v%"lc" == FALSE))
### in our dataframes
nodes = nodes[nodes$id %in% as.character(rgraph%v%"vertex.names"),]
edges = edges[which(edges$to %in% nodes$id | edges$from %in% nodes$id),]

# generate measures

## degree
rgraph%v%"degree" = degree(rgraph)
## mean geodesic
rgraph%v%"mean_distance" = (colSums(geodist(rgraph)$gdist)) / (nrow(as.sociomatrix(rgraph)) - 1)
## normalized betweenness
rgraph%v%"norm_betweenness" = betweenness(dat = rgraph, gmode = "graph", rescale = TRUE, cmode = "undirected")
## eigenvector
rgraph%v%"evc" = evcent(rgraph, gmode = "graph", rescale = TRUE)

# add back to attributes dataframe

## degree
nodes$degree = rgraph%v%"degree"
## mean geodesic
nodes$mean_distance = rgraph%v%"mean_distance"
## normalized betweenness
nodes$norm_betweenness = rgraph%v%"norm_betweenness"
## eigenvector
nodes$evc = rgraph%v%"evc"
```


```{r img_links, echo=FALSE}
# emojis
.net_url1 = "https://raw.githubusercontent.com/Epsian/sna_lecture/main/resources/male-teacher_emoji.png"
.net_url2 = "https://raw.githubusercontent.com/Epsian/sna_lecture/main/resources/female-student_emoji.png"
.net_url3 = "https://raw.githubusercontent.com/Epsian/sna_lecture/main/resources/female-health-worker_emoji.png"
.net_url4 = "https://raw.githubusercontent.com/Epsian/sna_lecture/main/resources/male-scientist_emoji.png"
```

Overview
================================================================================

Welcome! {data-width=400}
--------------------------------------------------------------------------------

### Welcome!

#### Report Introduction

This report will ingest pre-formatted network data and walk readers through some preliminary network metrics. All of the text in this report is generalized to any network it could render; it is not specific to the data displayed. Because of this, some metrics may not be relevant to a specific data set. Please talk with the DataLab about the outcomes of this report for help with interpretation and applications of these outcomes.

To navigate this report, use the tabs at the top of the page. Each page will walk you through one network metric and it's interpretation. The remainder of this tab will cover some network basics.

#### Network Background

You may be familiar with tabular data; rows and columns containing information. You can see a representation of this data to the right on top. While this is a tidy way to store data, it artificially atomizes or separates many of the things we are interested in as researchers, social or otherwise. Network analysis is a tool to work with *relational* data, a.k.a. information about how entities are connected with each other. For example, the diagram on the bottom right shows the same data as the table above, with the added benefit of showing how these individuals are connected to each other. Hover over the people to reveal the data about them.

Rather than looking only at attributes of specific data points, we are looking at the connections between data. In network analysis, data points are called *nodes* or *vertices*, and the connections between them are called *edges* or *ties*. Vertices can be anything---people, places, words, concepts---they are usually mapped into rows in a data frame. Edges contain any information on how these things connect or are related to each other. These components create a *network* or *graph*, defined as "finite set or sets of actors and the relation or relations defined on them" [@wassermanSocialNetworkAnalysis1994].

Data Types {data-width=600}
--------------------------------------------------------------------------------

### Example Data Frame

| Person | Name | Age | Widgets |
|-|:-|:-|:-|
| ![](`r .net_url1`){width="10%"} | J | 30 | 1 |
| ![](`r .net_url2`){width="10%"} | Y | 21 | 3 |
| ![](`r .net_url3`){width="10%"} | G | 32 | 4 |
| ![](`r .net_url4`){width="10%"} | Z | 48 | 8 |

### Example Network

```{r echo=FALSE, out.width='100%'}
.toy_nodes = data.frame(id = 1:4, 
                    shape = "image",
                    title = c("<p style='color: black;'>Name: J<br>Age: 30<br>Widgets: 1</p>", "<p style='color: black;'>Name: Y<br>Age: 21<br>Widgets: 3</p>", "<p style='color: black;'>Name: G<br>Age: 32<br>Widgets: 4</p>", "<p style='color: black;'>Name: Z<br>Age: 48<br>Widgets: 8</p>"),
                    image = c(.net_url1, .net_url2, .net_url3, .net_url4))

.toy_edges = data.frame(from = c(2,4,3,3), to = c(1,2,4,2), label = c("Siblings", "Student", "Friends", "Parent"))

.toy_net = visNetwork(.toy_nodes, .toy_edges, width = "100%") %>% 
  visNodes(shapeProperties = list(useBorderWithImage = FALSE), size = 50) %>%
  visEdges(length = 200, scaling = list(min = 400)) %>%
  visInteraction(zoomView = FALSE) %>%
  visLayout(randomSeed = 2)

.toy_net$sizingPolicy$browser$fill = TRUE

.toy_net
```

Network Metadata
================================================================================

Explanation Text
--------------------------------------------------------------------------------

### Network Characteristics

#### Density

This network has a density of ???

*Density* is the first real graph level metric that helps you understand what is particular about the network you are looking at. The density of a network is a numerical score showing how many ties exist in a network, given the max possible in that network. Mathematically that is $\frac{Actual Edges}{Possible Edges}$, where actual edges is the number of edges in the network, and possible edges is the number of edges if every single node in the network was connected to every other node.

Networks that are more densely connected are considered to be more cohesive and robust. This means that the removal of any specific edge or node will not have a great effect of the network as a whole. It also typically means that any one node in the network will be more likely to have access to whatever resources are in the network, as there are more potential connections in the network to search for resources.



Network Viewer
--------------------------------------------------------------------------------

### Network Overview


add projected or no, directional, weighted edges?

density, centralization

Degree
================================================================================

Degree Text {data-width=400}
--------------------------------------------------------------------------------

### Degree Measure

#### Description

*Degree* counts how many edges are connected to a node. Degree gives a very rough measure of how popular or central a node is in the network. If a node has more ties, it may indicate that node as being more central or important the network as a whole. Degree is a raw count of the number of edges a node has, this makes the interpretation of degree highly dependent on the size of the network. In a small network with only 25 total edges, having 10 of them would be significant. In a larger network with 250 total edges, 10 edges could be less impressive. Degree should thus be interpreted in the context of other nodes in the network. 

#### In This Network

```{r echo=FALSE}
hist(nodes$degree, main = "Degree Frequency", xlab = "Total Degree")
```

This network has a total of `r nrow(edges)` edges. The network on the right has the nodes scaled such that larger nodes have a higher total degree. The node highlighted in yellow in the right has the highest total degree at `r max(nodes$degree)` (`r (max(nodes$degree)/nrow(edges))*100` of all edges). 

Network Viewer {data-width=600}
--------------------------------------------------------------------------------

### Degree Network

```{r echo=FALSE}
# make dataframe for vis of degree
degree_df = nodes
degree_df$value = degree(rgraph)^2
degree_df$color = "#022851"

# add color for largest node
degree_df[which(max(degree_df$degree) == degree_df$degree), "color"] = "#FFBF00"

visNetwork(degree_df, edges) %>%
  visInteraction(zoomView = FALSE, dragView = FALSE) %>%
  visOptions(highlightNearest = TRUE) %>%
  visLayout(randomSeed = .seed)
```















Credits
================================================================================

DataLab {data-width=600}
--------------------------------------------------------------------------------

### About

This report was coded by [Jared Joseph](https://jnjoseph.com/) for the [UC Davis DataLab](https://datalab.ucdavis.edu/); I hope you found it useful! 

References {data-width=400}
--------------------------------------------------------------------------------

### References






